  <!--<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR.js con A-Frame</title>
  
  <!-- A-Frame estable (última versión estable conocida)  
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>

  <!-- AR.js para A-Frame (rama estable de AR.js) 
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/build/aframe-ar.min.js"></script>

  <!-- Gesture support (gestión de gestos con versiones modernas)  
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/examples/vendor/gesture-detector.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/examples/vendor/gesture-handler.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
  <a-scene
    vr-mode-ui="enabled: false"
    loading-screen="enabled: false"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
    embedded
    gesture-detector
  >
    <a-marker
      id="animated-marker"
      type="pattern"
      preset="custom"
      url="https://leonardoespina.github.io/ar/assets/codigos.patt"
      raycaster="objects: .clickable"
      emitevents="true"
      cursor="fuse: false; rayOrigin: mouse;"
    >
      <a-image
        src="assets/plato.png"
        scale="1 1 1"
        rotation="-90 0 0"
        class="clickable"
        gesture-handler
      ></a-image>
    </a-marker>

    <a-entity camera="fov: 50"></a-entity>
  </a-scene>
</body>
</html> -->
<!--<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Loader AR.js</title>

  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/build/aframe-ar.min.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }

    /* Estilos para el loader */
    #loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000; /* Fondo negro */
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: sans-serif;
      font-size: 1.5em;
      z-index: 100;
      transition: opacity 1s ease-in-out;
    }
    
    /* Clase para ocultar el loader */
    .hidden {
      opacity: 0;
      pointer-events: none;
    }

    /* CSS para solucionar el zoom en Chrome (por si acaso) */
    .a-video-frame {
        object-fit: contain !important;
    }
  </style>
</head>
<body>

  <div id="loader">
    Cargando...
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Obtenemos el elemento del loader
      const loader = document.getElementById('loader');

      // Creamos la escena AR.js pero no la mostramos aún
      const aScene = document.createElement('a-scene');
      aScene.setAttribute('vr-mode-ui', 'enabled: false');
      aScene.setAttribute('loading-screen', 'enabled: false');
      aScene.setAttribute('arjs', 'trackingMethod: best; sourceType: webcam; debugUIEnabled: false;');
      aScene.setAttribute('embedded', '');
      
      // Contenido de la escena
      aScene.innerHTML = `
        <a-marker type="pattern" preset="custom" url="https://leonardoespina.github.io/ar/assets/codigos.patt">
          <a-image
            src="assets/plato.png"
            scale="1 1 1"
            rotation="-90 0 0"
          ></a-image>
        </a-marker>
        <a-entity camera="fov: 50"></a-entity>
      `;

      // Simula una carga de 3 segundos
      setTimeout(() => {
        // Añade la escena AR.js al cuerpo del documento
        document.body.appendChild(aScene);
        
        // Oculta el loader de forma elegante
        loader.classList.add('hidden');
        
      }, 3000); // 3000 milisegundos = 3 segundos
    });
  </script>

</body>
</html>  
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Ahuyama 3D</title>

  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/build/aframe-ar.min.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }

    #loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: sans-serif;
      font-size: 1.5em;
      z-index: 100;
      transition: opacity 1s ease-in-out;
    }

    .hidden {
      opacity: 0;
      pointer-events: none;
    }

    .a-video-frame {
        object-fit: contain !important;
    }
  </style>
</head>
<body>
  
  <div id="loader">Cargando modelo 3D...</div>

  
  <a-scene
    vr-mode-ui="enabled: false"
    embedded
    arjs="sourceType: webcam; debugUIEnabled: false;"
    renderer="logarithmicDepthBuffer: true;"
  >
   
    <a-camera position="0 0 0" look-controls-enabled="false"></a-camera>

   
    <a-marker type="pattern" url="assets/codigos.patt">
      <a-entity
        id="modeloAhuyama"
        gltf-model="https://raw.githubusercontent.com/leonardoespina/web/my-new-branch/assets/assets/models/burger.glb"
        scale="2 2 2"
        position="0 0 0"
        rotation="0 0 0"
        animation-mixer
        gesture-handler
      ></a-entity>
    </a-marker>

 
    <a-entity camera></a-entity>
  </a-scene>

 
  <script>
    const model = document.querySelector('[gltf-model]');
    const loader = document.getElementById('loader');

    model.addEventListener('model-loaded', () => {
      loader.classList.add('hidden');
    });
  </script>

 
  <script>
    AFRAME.registerComponent('gesture-handler', {
      schema: { enabled: { default: true } },
      init: function () {
        const el = this.el;
        let isDragging = false;
        let previousTouches = [];

        el.sceneEl.canvas.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            isDragging = true;
          }
          previousTouches = [...e.touches];
        });

        el.sceneEl.canvas.addEventListener('touchmove', (e) => {
          if (!this.data.enabled) return;

          if (e.touches.length === 1 && isDragging) {
            const deltaX = e.touches[0].clientX - previousTouches[0].clientX;
            const deltaY = e.touches[0].clientY - previousTouches[0].clientY;

            const rotation = el.getAttribute('rotation');
            rotation.y += deltaX * 0.3;
            rotation.x += deltaY * 0.3;
            el.setAttribute('rotation', rotation);
          }

          if (e.touches.length === 2 && previousTouches.length === 2) {
            const currentDist = getTouchDistance(e.touches[0], e.touches[1]);
            const prevDist = getTouchDistance(previousTouches[0], previousTouches[1]);

            const scale = el.getAttribute('scale');
            let zoomFactor = currentDist / prevDist;
            zoomFactor = Math.min(Math.max(zoomFactor, 0.9), 1.1); // Limitar zoom por frame

            const newScale = {
              x: scale.x * zoomFactor,
              y: scale.y * zoomFactor,
              z: scale.z * zoomFactor
            };

            // Limitar tamaño final del modelo
            const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
            newScale.x = clamp(newScale.x, 0.5, 5);
            newScale.y = clamp(newScale.y, 0.5, 5);
            newScale.z = clamp(newScale.z, 0.5, 5);

            el.setAttribute('scale', `${newScale.x} ${newScale.y} ${newScale.z}`);
          }

          previousTouches = [...e.touches];
        });

        el.sceneEl.canvas.addEventListener('touchend', () => {
          isDragging = false;
          previousTouches = [];
        });

        function getTouchDistance(p1, p2) {
          const dx = p2.clientX - p1.clientX;
          const dy = p2.clientY - p1.clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }
      }
    });
  </script>
</body>
</html> -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Image Tracking - Burger</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <!-- A-Frame y AR.js con NFT -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/build/aframe-ar-nft.min.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }
    #loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: sans-serif;
      font-size: 1.5em;
      z-index: 100;
      transition: opacity 1s ease-in-out;
    }
    .hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Loader -->
  <div id="loader">Cargando modelo 3D...</div>

  <!-- Escena AR con NFT -->
  <a-scene
    vr-mode-ui="enabled: false"
    embedded
    renderer="logarithmicDepthBuffer: true;"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
  >
    <!-- Cámara -->
    <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

    <!-- Seguimiento de Imagen NFT -->
    <a-nft
      type="nft"
      url="assets/nft/imagen"  <!-- sin extensión: AR.js busca .fset, .fset3, .iset automáticamente -->
      smooth="true"
      smoothCount="10"
      smoothTolerance="0.01"
      smoothThreshold="5"
    >
      <a-entity
        id="modeloBurger"
        gltf-model="https://raw.githubusercontent.com/leonardoespina/web/my-new-branch/assets/assets/models/burger.glb"
        scale="2 2 2"
        position="0 0 0"
        rotation="0 0 0"
        animation-mixer
        gesture-handler
      ></a-entity>
    </a-nft>

    <!-- Escena base -->
    <a-entity camera></a-entity>
  </a-scene>

  <!-- Script para ocultar loader -->
  <script>
    const model = document.querySelector('[gltf-model]');
    const loader = document.getElementById('loader');

    model.addEventListener('model-loaded', () => {
      loader.classList.add('hidden');
    });
  </script>

  <!-- Gesture handler (rotar + zoom + mover) -->
  <script>
    AFRAME.registerComponent('gesture-handler', {
      schema: { enabled: { default: true } },
      init: function () {
        const el = this.el;
        let previousTouches = [];
        let previousMidpoint = null;

        el.sceneEl.canvas.addEventListener('touchstart', (e) => {
          previousTouches = [...e.touches];
          if (e.touches.length === 2) {
            previousMidpoint = getMidpoint(e.touches[0], e.touches[1]);
          }
        });

        el.sceneEl.canvas.addEventListener('touchmove', (e) => {
          if (!this.data.enabled) return;

          // Rotación
          if (e.touches.length === 1 && previousTouches.length === 1) {
            const deltaX = e.touches[0].clientX - previousTouches[0].clientX;
            const deltaY = e.touches[0].clientY - previousTouches[0].clientY;

            const rotation = el.getAttribute('rotation');
            rotation.y += deltaX * 0.3;
            rotation.x += deltaY * 0.3;
            el.setAttribute('rotation', rotation);
          }

          // Zoom + desplazamiento
          if (e.touches.length === 2 && previousTouches.length === 2) {
            const currentDist = getTouchDistance(e.touches[0], e.touches[1]);
            const prevDist = getTouchDistance(previousTouches[0], previousTouches[1]);

            const scale = el.getAttribute('scale');
            let zoomFactor = currentDist / prevDist;
            zoomFactor = Math.min(Math.max(zoomFactor, 0.9), 1.1);

            const newScale = {
              x: clamp(scale.x * zoomFactor, 0.5, 5),
              y: clamp(scale.y * zoomFactor, 0.5, 5),
              z: clamp(scale.z * zoomFactor, 0.5, 5)
            };
            el.setAttribute('scale', `${newScale.x} ${newScale.y} ${newScale.z}`);

            // Desplazamiento
            const currentMid = getMidpoint(e.touches[0], e.touches[1]);
            const deltaX = currentMid.x - previousMidpoint.x;
            const deltaY = currentMid.y - previousMidpoint.y;

            const position = el.getAttribute('position');
            const movementFactor = 0.01;
            position.x += deltaX * movementFactor;
            position.y -= deltaY * movementFactor;
            el.setAttribute('position', position);

            previousMidpoint = currentMid;
          }

          previousTouches = [...e.touches];
        });

        el.sceneEl.canvas.addEventListener('touchend', () => {
          previousTouches = [];
          previousMidpoint = null;
        });

        function getTouchDistance(p1, p2) {
          const dx = p2.clientX - p1.clientX;
          const dy = p2.clientY - p1.clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }

        function getMidpoint(p1, p2) {
          return {
            x: (p1.clientX + p2.clientX) / 2,
            y: (p1.clientY + p2.clientY) / 2
          };
        }

        function clamp(val, min, max) {
          return Math.min(Math.max(val, min), max);
        }
      }
    });
  </script>
</body>
</html>

